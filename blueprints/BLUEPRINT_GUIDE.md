# Blueprint Authoring Guide

This guide describes the blueprint file format and walks you through creating
your first blueprint from scratch.

A blueprint is a set of YAML files that declaratively describe how to set up a
development environment for a specific hardware target. When published, it
becomes an Alloy Imageimage that `alloy-provisioner` pulls and executes inside a Linux
VM.

---

## Quick Start

```bash
# 1. Create a blueprint directory
mkdir -p blueprints/my-vendor/my-board

# 2. Create the manifest
cat > blueprints/my-vendor/my-board/manifest.yml << 'EOF'
name: "My Board Dev Environment"
version: "1.0.0"
description: "Cross-compilation tools for My Board."

variables:
  MY_SDK_DEST: "/opt/my-sdk"

run_order:
  - "00-system.yml"
  - "99-cleanup.yml"
EOF

# 3. Create a task file
cat > blueprints/my-vendor/my-board/00-system.yml << 'EOF'
- name: "Install build tools"
  action: "apt_install"
  packages:
    - build-essential
    - cmake
    - git
EOF

# 4. Create the cleanup file
cat > blueprints/my-vendor/my-board/99-cleanup.yml << 'EOF'
- name: "Clean APT cache"
  action: "run_command"
  command: "apt-get clean && rm -rf /var/lib/apt/lists/*"
EOF

# 5. Validate
alloy-cicd validate --dir blueprints/my-vendor/my-board
```

---

## Directory Layout

Every blueprint lives under `blueprints/<vendor>/<board>/`:

```text
blueprints/
  my-vendor/
    my-board/
      manifest.yml           # Required: metadata, variables, execution order
      variables.yml          # Optional: extra variables (merged into manifest)
      00-system.yml          # Task file
      10-toolchain.yml       # Task file
      20-sdk.yml             # Task file
      99-cleanup.yml         # Task file
      alloy.lock.yml         # Auto-generated (do not edit)
```

The `<vendor>/<board>` path becomes the Alloy Imageimage name:

```text
blueprints/nordic/nrf91/  →  api.alloy-it.io/community/nordic/nrf91:1.0.0
blueprints/raspberry-pi/raspberry-pi-5/  →  api.alloy-it.io/community/raspberry-pi/raspberry-pi-5:1.0.0
```

---

## File Reference

### manifest.yml

The manifest is the entry point. It defines what the blueprint is, what
variables it uses, and in what order task files are executed.

```yaml
# Required fields
name: "Nordic nRF91 Dev Environment"
version: "1.0.0"

# Optional
description: "ARM toolchain, Zephyr RTOS, and nRF Connect SDK for nRF91 series."

# Variables available to task files via {{.Vars.NAME}}
variables:
  ARM_TOOLCHAIN_DEST: "/opt/arm-none-eabi"
  ARM_TOOLCHAIN_URL_amd64: "https://developer.arm.com/.../x86_64-arm-none-eabi.tar.xz"
  ARM_TOOLCHAIN_SHA_amd64: "95c011cee430e64dd6087c75c800f04b9c49832cc1000..."
  ARM_TOOLCHAIN_URL_arm64: "https://developer.arm.com/.../aarch64-arm-none-eabi.tar.xz"
  ARM_TOOLCHAIN_SHA_arm64: "c8824bffd057afce2259f7618254e840715f33523a3d..."

# Optional: OS/arch supported hosts for CI/CD (one image per host; default: [linux/amd64])
supported_hosts:
  - linux/amd64
  - linux/arm64

# Optional: catalog references (resolved to alloy.lock.yml)
toolchains:
  - ref: "toolchain.arm-gnu.arm-none-eabi@stable"
    alias: ARM_TOOLCHAIN
  - ref: "sdk.golang.go@1.24.4"
    alias: GOLANG

# Required: ordered list of task files to execute
run_order:
  - "00-system-base.yml"
  - "10-arm-toolchain.yml"
  - "20-nrf-sdk.yml"
  - "99-cleanup.yml"
```

#### Fields

| Field         | Required | Type              | Description                                                                 |
| ------------- | -------- | ----------------- | --------------------------------------------------------------------------- |
| `name`        | Yes      | string            | Human-readable name                                                         |
| `version`     | Yes      | string            | Semantic version (e.g., `1.0.0`)                                            |
| `description` | No       | string            | Brief description                                                           |
| `variables`   | No       | map[string]string | Key-value pairs for template expansion                                      |
| `supported_hosts` | No   | list of strings   | OS/arch platforms for CI/CD (e.g. `linux/amd64`, `linux/arm64`). Default: `[linux/amd64]`. |
| `toolchains`  | No       | list              | Catalog references to resolve via the catalog                              |
| `run_order`   | Yes      | list of strings   | Task filenames in execution order                                           |

### variables.yml (optional)

An optional file with additional variables. These are merged into the manifest
variables. If the same key exists in both files, the manifest value wins.

```yaml
EXTRA_PACKAGES: "vim htop"
DEBUG_MODE: "false"
```

### alloy.lock.yml (auto-generated)

Created by `alloy-cicd resolve`. Pins every catalog reference to a concrete
URL and SHA256 for a specific host platform. Never edit this file manually.

```yaml
# AUTO-GENERATED by alloy-cicd resolve. Do not edit.
resolved_at: "2026-02-15T10:30:00Z"
host: linux/amd64
toolchains:
  toolchain.arm-gnu.arm-none-eabi@stable:
    url: "https://developer.arm.com/.../x86_64-arm-none-eabi.tar.xz"
    sha256: "95c011cee430e64dd6087c75c800f04b9c49832cc1000..."
    method: "archive"
```

---

## Task Files

A task file is a YAML array of steps. Each step has a `name` and an `action`.
Steps are executed in order, top to bottom. Task files themselves are executed
in the order specified by `run_order` in the manifest.

```yaml
# 10-toolchain.yml
- name: "Create directories"
  action: "run_command"
  command: "mkdir -p /opt/toolchain"
  creates: "/opt/toolchain"

- name: "Download and extract toolchain"
  action: "unarchive_from_url"
  dest: "/opt/toolchain"
  creates: "/opt/toolchain/bin/gcc"
  per_arch:
    amd64:
      url: "{{.Vars.TOOLCHAIN_URL_amd64}}"
      sha256: "{{.Vars.TOOLCHAIN_SHA_amd64}}"
    arm64:
      url: "{{.Vars.TOOLCHAIN_URL_arm64}}"
      sha256: "{{.Vars.TOOLCHAIN_SHA_arm64}}"
```

### Common Fields

Every task supports these fields:

| Field      | Required | Description                                                  |
| ---------- | -------- | ------------------------------------------------------------ |
| `name`     | Yes      | Human-readable step name (shown in provisioner output)       |
| `action`   | Yes      | One of the action types described below                      |
| `creates`  | No       | Path to check before running; if it exists, skip this step   |
| `owner`    | No       | Set ownership after execution (e.g., `root:root`)            |
| `mode`     | No       | Set permissions (octal or symbolic, see Permissions section) |
| `per_arch` | No       | Per-architecture overrides (see Architecture section)        |

### Template Variables

All string fields in tasks support Go template expansion:

```yaml
dest: "{{.Vars.MY_SDK_DEST}}"
command: "echo {{.Vars.MY_VERSION}}"
content: "export PATH=$PATH:{{.Vars.MY_SDK_DEST}}/bin"
```

Variable sources (highest priority first):

1. OS environment variables
2. `variables:` in manifest.yml
3. `variables.yml` file
4. Injected toolchain variables from lockfile (`{ALIAS}_URL`, `{ALIAS}_SHA`)

---

## Actions

### `apt_install`

Installs system packages using `apt-get install -y`.

```yaml
- name: "Install build tools"
  action: "apt_install"
  packages:
    - build-essential
    - cmake
    - ninja-build
    - git
    - python3
    - python3-pip
```

To pin a specific version, use APT's `package=version` syntax:

```yaml
- name: "Install Python 3.9"
  action: "apt_install"
  packages:
    - "python3.9=3.9.2-1"
```

| Field      | Required | Description                                                                 |
| ---------- | -------- | --------------------------------------------------------------------------- |
| `packages` | Yes      | List of apt packages. Use `name=version` for a specific version (e.g. `python3.9=3.9.2-1`). |

The provisioner runs `apt-get update` before installing.

### `run_command`

Executes a shell command via `bash -c`.

```yaml
- name: "Create SDK directory"
  action: "run_command"
  command: "mkdir -p /opt/sdk"
  creates: "/opt/sdk"
```

Multi-line commands:

```yaml
- name: "Initialize SDK"
  action: "run_command"
  command: |
    set -e
    cd /opt/sdk
    west init -m https://github.com/example/sdk --mr v2.0
    west update
  creates: "/opt/sdk/.west"
```

| Field     | Required | Description              |
| --------- | -------- | ------------------------ |
| `command` | Yes      | Shell command to execute |

Commands run as root. Use `creates` to make them idempotent.

### `get_file`

Downloads a file from a URL and verifies its SHA256 checksum.

```yaml
- name: "Download firmware image"
  action: "get_file"
  url: "https://example.com/firmware-v2.0.bin"
  sha256: "abc123def456..."
  dest: "/opt/firmware/firmware-v2.0.bin"
  creates: "/opt/firmware/firmware-v2.0.bin"
```

| Field    | Required | Description                            |
| -------- | -------- | -------------------------------------- |
| `url`    | Yes      | Download URL (can be in `per_arch`)    |
| `sha256` | No       | SHA256 checksum (can be in `per_arch`) |
| `dest`   | Yes      | Destination file path                  |

If the checksum does not match, the file is deleted and the task fails.

### `unpack`

Extracts a local archive using `tar -xaf`.

```yaml
- name: "Extract SDK"
  action: "unpack"
  source: "/tmp/sdk.tar.gz"
  dest: "/opt/sdk"
  creates: "/opt/sdk/bin/tool"
```

| Field    | Required | Description              |
| -------- | -------- | ------------------------ |
| `source` | Yes      | Path to the archive file |
| `dest`   | Yes      | Extraction directory     |

### `unarchive_from_url`

Downloads an archive and extracts it in one step. This is the most commonly
used action for installing toolchains and SDKs.

```yaml
- name: "Install Go"
  action: "unarchive_from_url"
  dest: "/usr/local"
  creates: "/usr/local/go/bin/go"
  mode: "USER_RWX GROUP_RX OTHER_RX"
  per_arch:
    amd64:
      url: "{{.Vars.GOLANG_URL_amd64}}"
      sha256: "{{.Vars.GOLANG_SHA_amd64}}"
    arm64:
      url: "{{.Vars.GOLANG_URL_arm64}}"
      sha256: "{{.Vars.GOLANG_SHA_arm64}}"
```

| Field    | Required | Description                            |
| -------- | -------- | -------------------------------------- |
| `url`    | Yes      | Download URL (can be in `per_arch`)    |
| `sha256` | No       | SHA256 checksum (can be in `per_arch`) |
| `dest`   | Yes      | Extraction directory                   |

The archive format is auto-detected from the URL extension (`.tar.gz`,
`.tar.xz`, `.tar.bz2`, `.zip`).

### `unarchive_from_ref`

Same as `unarchive_from_url` but the URL and SHA256 come from a catalog
reference resolved via the lockfile.

```yaml
- name: "Install ARM toolchain from catalog"
  action: "unarchive_from_ref"
  ref: "toolchain.arm-gnu.arm-none-eabi@stable"
  dest: "/opt/arm-toolchain"
  creates: "/opt/arm-toolchain/bin/arm-none-eabi-gcc"
```

| Field  | Required | Description                                      |
| ------ | -------- | ------------------------------------------------ |
| `ref`  | Yes      | Catalog reference (e.g., `sdk.golang.go@1.24.4`) |
| `dest` | Yes      | Extraction directory                             |

The ref must exist in the manifest's `toolchains:` section and be resolved
in `alloy.lock.yml`.

### `write_env_file`

Writes content to a file. Commonly used for `/etc/profile.d/` scripts to set
environment variables.

```yaml
- name: "Add toolchain to PATH"
  action: "write_env_file"
  file: "/etc/profile.d/10-toolchain.sh"
  content: |
    #!/bin/sh
    export PATH=$PATH:/opt/arm-toolchain/bin
    export CROSS_COMPILE=arm-none-eabi-
  mode: "USER_RWX GROUP_RX OTHER_RX"
```

| Field     | Required | Description           |
| --------- | -------- | --------------------- |
| `file`    | Yes      | Destination file path |
| `content` | Yes      | File content to write |

Also useful for udev rules, CMake toolchain files, and config files:

```yaml
- name: "Create udev rules for USB devices"
  action: "write_env_file"
  file: "/etc/udev/rules.d/99-my-device.rules"
  content: |
    SUBSYSTEM=="usb", ATTR{idVendor}=="1234", MODE="0666", GROUP="plugdev"
  mode: "USER_RW GROUP_R OTHER_R"
```

### `install_target_lib`

Downloads a `.deb` package and extracts it into a sysroot directory. Used for
cross-compilation when you need target libraries on the host.

```yaml
- name: "Install libc for ARM target"
  action: "install_target_lib"
  url: "https://packages.example.com/libc6-arm64.deb"
  sha256: "abc123..."
  dest: "/opt/sysroot"
```

| Field    | Required | Description                                |
| -------- | -------- | ------------------------------------------ |
| `url`    | Yes      | URL to .deb package (can be in `per_arch`) |
| `sha256` | No       | SHA256 checksum (can be in `per_arch`)     |
| `dest`   | Yes      | Sysroot directory to extract into          |

### `build_from_source`

Downloads source code, extracts it, and runs build commands. Use this when no
prebuilt binary is available for the target platform.

```yaml
- name: "Build genimage from source"
  action: "build_from_source"
  url: "https://github.com/pengutronix/genimage/releases/download/v15/genimage-15.tar.xz"
  sha256: "9bca24bf883310b30ee4511cbc3a580e40ad4540..."
  dest: "/opt/genimage-build"
  command: |
    cd genimage-*
    ./configure --prefix=/usr/local
    make -j$(nproc)
    make install
  creates: "/usr/local/bin/genimage"
```

| Field     | Required | Description                                  |
| --------- | -------- | -------------------------------------------- |
| `url`     | Yes      | URL to source archive (can be in `per_arch`) |
| `sha256`  | No       | SHA256 checksum (can be in `per_arch`)       |
| `dest`    | Yes      | Build directory                              |
| `command` | Yes      | Build commands to execute                    |

---

## Architecture-Specific Overrides

The provisioner detects the host CPU architecture at runtime:

| `uname -m` output | Maps to |
| ----------------- | ------- |
| `x86_64`          | `amd64` |
| `aarch64`         | `arm64` |

Use the `per_arch` block to provide different URLs, checksums, or commands
for each architecture:

```yaml
- name: "Install ARM Toolchain"
  action: "unarchive_from_url"
  dest: "/opt/arm-toolchain"
  creates: "/opt/arm-toolchain/bin/arm-none-eabi-gcc"
  per_arch:
    amd64:
      url: "https://developer.arm.com/.../x86_64-arm-none-eabi.tar.xz"
      sha256: "95c011cee430e64dd6087c75c800f04b9c49832cc1000..."
    arm64:
      url: "https://developer.arm.com/.../aarch64-arm-none-eabi.tar.xz"
      sha256: "c8824bffd057afce2259f7618254e840715f33523a3d..."
```

Fields in `per_arch` override the same fields at the task level. The following
fields can be overridden:

| Field     | Supported in `per_arch` |
| --------- | ----------------------- |
| `url`     | Yes                     |
| `sha256`  | Yes                     |
| `command` | Yes                     |
| `source`  | Yes                     |

If a task does not have a `per_arch` block, it runs identically on all
architectures. This is fine for actions like `apt_install`, `run_command`,
and `write_env_file` that are architecture-independent.

---

## Permissions

### `mode`

Set file or directory permissions after a task completes. Accepts either
symbolic or octal notation:

**Symbolic (recommended):**

| Value                         | Octal | Description                          |
| ----------------------------- | ----- | ------------------------------------ |
| `USER_RWX GROUP_RX OTHER_RX`  | 0755  | Executable by all, writable by owner |
| `USER_RW GROUP_R OTHER_R`     | 0644  | Readable by all, writable by owner   |
| `USER_RWX`                    | 0700  | Owner only, full access              |
| `USER_RW`                     | 0600  | Owner only, read/write               |

Symbolic mode components must be **space-separated** (e.g. `USER_RW GROUP_R OTHER_R`). Underscore-joined values like `USER_RW GROUP_R OTHER_R` are not supported.

**Octal:**

```yaml
mode: "0755"
```

### `owner`

Set ownership using `user:group` format:

```yaml
owner: "root:root"
```

Permissions are applied recursively to `dest` or `file` after the action
completes.

---

## Idempotency with `creates`

The `creates` field makes a task idempotent. Before running the task, the
provisioner checks if the path exists. If it does, the task is skipped.

```yaml
- name: "Install Go"
  action: "unarchive_from_url"
  dest: "/usr/local"
  creates: "/usr/local/go/bin/go" # Skip if Go is already installed
  per_arch:
    amd64:
      url: "{{.Vars.GOLANG_URL_amd64}}"
      sha256: "{{.Vars.GOLANG_SHA_amd64}}"
```

**Best practice:** Always set `creates` on tasks that download or install
something. This prevents re-downloading on re-provision and makes the
blueprint safe to run multiple times.

Good `creates` values:

- The main binary: `creates: "/usr/local/go/bin/go"`
- A known directory: `creates: "/opt/sdk/.west"`
- A sentinel file: `creates: "/opt/sdk/.setup_complete"`

---

## Catalog References

Instead of hardcoding download URLs in variables, you can reference tools
from the catalog. You describe the blueprint once; the catalog declares which
host platforms each tool supports (e.g. `linux/amd64`, `linux/arm64`,
`darwin/amd64`, `darwin/arm64`), and resolution assigns the correct URL and
SHA256 for the current host OS and architecture.

### How It Works

1. Add a `toolchains:` entry in `manifest.yml`:

   ```yaml
   toolchains:
     - ref: "sdk.golang.go@stable"
       alias: GOLANG
   ```

2. `alloy-cicd resolve` (or `alloy-host resolve`) looks up `sdk.golang.go`
   in the catalog, expands the `@stable` alias to a concrete version, picks
   the URL/SHA for the current host (e.g. darwin/arm64 on macOS Apple Silicon,
   linux/amd64 on Linux x86_64), and writes them to `alloy.lock.yml`.

3. If you specified an `alias`, two variables are injected:
   - `{{.Vars.GOLANG_URL}}` -- the resolved download URL
   - `{{.Vars.GOLANG_SHA}}` -- the resolved SHA256 checksum

4. Use them in task files:

   ```yaml
   - name: "Install Go from catalog"
     action: "unarchive_from_url"
     dest: "/usr/local"
     creates: "/usr/local/go/bin/go"
     url: "{{.Vars.GOLANG_URL}}"
     sha256: "{{.Vars.GOLANG_SHA}}"
   ```

   Or use `unarchive_from_ref` directly:

   ```yaml
   - name: "Install Go from catalog"
     action: "unarchive_from_ref"
     ref: "sdk.golang.go@stable"
     dest: "/usr/local"
     creates: "/usr/local/go/bin/go"
   ```

### Ref Format

```text
<catalog-id>@<version-or-alias>
```

Examples:

| Ref                                         | Meaning                         |
| ------------------------------------------- | ------------------------------- |
| `sdk.golang.go@stable`                      | Latest stable Go                |
| `sdk.golang.go@1.24.4`                      | Exact Go version                |
| `toolchain.arm-gnu.arm-none-eabi@latest`    | Latest ARM bare-metal toolchain |
| `toolchain.arm-gnu.arm-none-eabi@13.3.rel1` | Exact ARM toolchain version     |

Available aliases depend on the tool's `index.yaml` in the catalog (typically
`stable`, `latest`, and sometimes `lts`).

---

## Tutorial: Create a Raspberry Pi Blueprint

This walks through creating a complete blueprint for a Raspberry Pi board.

### 1. Create the Directory

```bash
mkdir -p blueprints/raspberry-pi/raspberry-pi-zero-2-w
```

### 2. Create the Manifest

```yaml
# blueprints/raspberry-pi/raspberry-pi-zero-2-w/manifest.yml
name: "Raspberry Pi Zero 2 W Dev Environment"
version: "1.0.0"
description: "Cross-compilation toolchain for Raspberry Pi Zero 2 W (64-bit, aarch64)."

variables:
  # Go
  GOLANG_VERSION: "1.24.4"
  GOLANG_URL_amd64: "https://go.dev/dl/go1.24.4.linux-amd64.tar.gz"
  GOLANG_SHA_amd64: "77e5da33bb72aeaef1ba4418b6fe511bc4d041873cbf82e5aa6318740df98717"
  GOLANG_URL_arm64: "https://go.dev/dl/go1.24.4.linux-arm64.tar.gz"
  GOLANG_SHA_arm64: "d5501ee5aca0f258d5fe9bfaed401958445014495dc115f202d43d5210b45241"

  # ARM 64-bit cross-compiler
  TOOLCHAIN_DEST: "/opt/cross-pi/aarch64-linux-gnu"
  TOOLCHAIN_URL_amd64: "https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz"
  TOOLCHAIN_SHA_amd64: "f0d87abe3dcc24797823f41a8c4eef0c8a76e82ab6ce30f43dc5f97c4b2b1b46"
  TOOLCHAIN_URL_arm64: "https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-aarch64-aarch64-none-linux-gnu.tar.xz"
  TOOLCHAIN_SHA_arm64: "b3a7f1e88bf36fc7bb6cedd5d62a0e3e8a0eb2d30b61cdad7bcea02f7a303a94"

  # CMake
  CMAKE_TOOLCHAIN_DIR: "/opt/cross-pi/cmake"

run_order:
  - "00-system.yml"
  - "10-host-tools.yml"
  - "20-toolchain.yml"
  - "99-cleanup.yml"
```

### 3. Create Task Files

**00-system.yml** -- system packages:

```yaml
- name: "Update APT cache"
  action: "run_command"
  command: "apt-get update -y"

- name: "Install base packages"
  action: "apt_install"
  packages:
    - build-essential
    - cmake
    - git
    - wget
    - curl
    - xz-utils
    - python3
    - python3-pip
    - device-tree-compiler
    - u-boot-tools
```

**10-host-tools.yml** -- Go SDK:

```yaml
- name: "Install Go"
  action: "unarchive_from_url"
  dest: "/usr/local"
  creates: "/usr/local/go/bin/go"
  mode: "USER_RWX GROUP_RX OTHER_RX"
  per_arch:
    amd64:
      url: "{{.Vars.GOLANG_URL_amd64}}"
      sha256: "{{.Vars.GOLANG_SHA_amd64}}"
    arm64:
      url: "{{.Vars.GOLANG_URL_arm64}}"
      sha256: "{{.Vars.GOLANG_SHA_arm64}}"

- name: "Add Go to PATH"
  action: "write_env_file"
  file: "/etc/profile.d/10-golang.sh"
  content: |
    #!/bin/sh
    export PATH=$PATH:/usr/local/go/bin
    export GOPATH=$HOME/go
    export PATH=$PATH:$GOPATH/bin
  mode: "USER_RWX GROUP_RX OTHER_RX"
```

**20-toolchain.yml** -- cross-compiler:

```yaml
- name: "Create toolchain directories"
  action: "run_command"
  command: |
    mkdir -p {{.Vars.TOOLCHAIN_DEST}}
    mkdir -p {{.Vars.CMAKE_TOOLCHAIN_DIR}}
  creates: "{{.Vars.CMAKE_TOOLCHAIN_DIR}}"

- name: "Install aarch64 cross-compiler"
  action: "unarchive_from_url"
  dest: "{{.Vars.TOOLCHAIN_DEST}}"
  creates: "{{.Vars.TOOLCHAIN_DEST}}/bin/aarch64-none-linux-gnu-gcc"
  mode: "USER_RWX GROUP_RX OTHER_RX"
  owner: "root:root"
  per_arch:
    amd64:
      url: "{{.Vars.TOOLCHAIN_URL_amd64}}"
      sha256: "{{.Vars.TOOLCHAIN_SHA_amd64}}"
    arm64:
      url: "{{.Vars.TOOLCHAIN_URL_arm64}}"
      sha256: "{{.Vars.TOOLCHAIN_SHA_arm64}}"

- name: "Add cross-compiler to PATH"
  action: "write_env_file"
  file: "/etc/profile.d/20-toolchain.sh"
  content: |
    #!/bin/sh
    export PATH=$PATH:{{.Vars.TOOLCHAIN_DEST}}/bin
    export CROSS_COMPILE=aarch64-none-linux-gnu-
  mode: "USER_RWX GROUP_RX OTHER_RX"

- name: "Create CMake toolchain file"
  action: "write_env_file"
  file: "{{.Vars.CMAKE_TOOLCHAIN_DIR}}/aarch64-linux-gnu.cmake"
  content: |
    set(CMAKE_SYSTEM_NAME Linux)
    set(CMAKE_SYSTEM_PROCESSOR aarch64)
    set(CMAKE_C_COMPILER {{.Vars.TOOLCHAIN_DEST}}/bin/aarch64-none-linux-gnu-gcc)
    set(CMAKE_CXX_COMPILER {{.Vars.TOOLCHAIN_DEST}}/bin/aarch64-none-linux-gnu-g++)
  mode: "USER_RW GROUP_R OTHER_R"
```

**99-cleanup.yml** -- reduce image size and verify:

```yaml
- name: "Clean APT cache"
  action: "run_command"
  command: |
    apt-get clean
    rm -rf /var/lib/apt/lists/*

- name: "Verify installation"
  action: "run_command"
  command: |
    echo "=== Raspberry Pi Zero 2 W Dev Environment ==="
    echo ""
    echo "Go:"
    /usr/local/go/bin/go version
    echo ""
    echo "Cross-compiler:"
    {{.Vars.TOOLCHAIN_DEST}}/bin/aarch64-none-linux-gnu-gcc --version | head -1
    echo ""
    echo "CMake:"
    cmake --version | head -1
    echo ""
    echo "=== Ready! ==="
```

### 4. Validate

```bash
alloy-cicd validate --dir blueprints/raspberry-pi/raspberry-pi-zero-2-w
```

### 5. Test Resolution (optional)

If your blueprint uses catalog references:

```bash
alloy-cicd resolve \
  --dir blueprints/raspberry-pi/raspberry-pi-zero-2-w \
  --catalog-dir . \
  --host-platform linux/amd64
```

### 6. Submit a PR

Push your branch and open a pull request. CI will automatically:

1. Validate the blueprint YAML structure.
2. Run a dry-run resolution to verify catalog references.

On merge, the blueprint is published as an Alloy Imageimage to:

```text
api.alloy-it.io/community/raspberry-pi/raspberry-pi-zero-2-w:1.0.0
```

---

## Naming Conventions

| Item             | Convention                    | Examples                               |
| ---------------- | ----------------------------- | -------------------------------------- |
| Vendor directory | Lowercase, hyphens            | `nordic`, `raspberry-pi`, `espressif`  |
| Board directory  | Lowercase, hyphens, full name | `nrf91`, `raspberry-pi-5`, `esp32-s3`  |
| Task files       | Numbered prefix, hyphens      | `00-system.yml`, `10-toolchain.yml`    |
| Variables        | UPPER_SNAKE_CASE              | `ARM_TOOLCHAIN_DEST`, `GOLANG_VERSION` |
| Arch suffixes    | `_amd64`, `_arm64`            | `TOOLCHAIN_URL_amd64`                  |

---

## Best Practices

1. **Always use `creates` for idempotency.** Every task that installs
   something should set `creates` so it is skipped on re-provision.

2. **Provide both `amd64` and `arm64` in `per_arch`.** This ensures the
   blueprint works on both Intel and ARM hosts.

3. **Use variables for URLs and checksums.** Keep task files clean. Put all
   version-specific values in the manifest's `variables:` block.

4. **Number your task files.** Use `00-`, `10-`, `20-`, `99-` prefixes so the
   execution order is obvious at a glance.

5. **Put cleanup last.** A `99-cleanup.yml` that clears apt caches reduces
   the final image size.

6. **Use `set -e` in multi-line commands.** This ensures the task fails on
   the first error:

   ```yaml
   command: |
     set -e
     cd /opt/sdk
     west init
     west update
   ```

7. **Write environment files to `/etc/profile.d/`.** This makes environment
   variables available to all users and shells.

8. **Test locally before submitting.** Run `alloy-cicd validate` to catch
   syntax errors early.
